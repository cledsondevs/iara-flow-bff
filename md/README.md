# Iara Flow BFF - Backend para Frontend

Este repositÃ³rio contÃ©m o backend para frontend (BFF) do Iara Flow, um agente de modelos construÃ­do com LangChain e banco de dados SQLite. O projeto foi modularizado para facilitar a manutenÃ§Ã£o e escalabilidade.

## ğŸ”§ CorreÃ§Ãµes Recentes (Branch: fix-optimize-backlog-generation)

### Problema Corrigido

- **Erro**: `'EnhancedMemoryService' object has no attribute 'optimize_backlog_generation'`
- **Causa**: MÃ©todo `optimize_backlog_generation` estava sendo chamado no `ReviewAgentService` mas nÃ£o estava implementado na classe `EnhancedMemoryService`
- **SoluÃ§Ã£o**: Implementado o mÃ©todo faltante com funcionalidades completas de otimizaÃ§Ã£o de backlog

### ImplementaÃ§Ãµes Adicionadas

1. **`optimize_backlog_generation()`**: MÃ©todo principal que otimiza a geraÃ§Ã£o de backlog baseado na memÃ³ria de longo prazo
2. **`_calculate_priority_adjustments()`**: Calcula ajustes de prioridade baseados em padrÃµes e tendÃªncias
3. **`_identify_focus_areas()`**: Identifica Ã¡reas de foco baseadas em problemas frequentes e tendÃªncias negativas

### Funcionalidades do MÃ©todo

- AnÃ¡lise de padrÃµes de otimizaÃ§Ã£o aprendidos
- IdentificaÃ§Ã£o de soluÃ§Ãµes efetivas para problemas similares
- AnÃ¡lise de tendÃªncias de sentimento
- Ajustes automÃ¡ticos de prioridade
- RecomendaÃ§Ã£o de Ã¡reas de foco

## Estrutura do Projeto

A estrutura do projeto foi organizada de forma modular, separando as responsabilidades em diretÃ³rios claros:

```
app/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ main.py                    # AplicaÃ§Ã£o principal Flask
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ settings.py           # ConfiguraÃ§Ãµes centralizadas da aplicaÃ§Ã£o
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ database.py           # UtilitÃ¡rios para conexÃ£o e inicializaÃ§Ã£o do banco de dados
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ routes.py             # Rotas de autenticaÃ§Ã£o (registro, login, logout, verificaÃ§Ã£o, usuÃ¡rios)
â”‚   â””â”€â”€ middleware.py         # Middleware de autenticaÃ§Ã£o para proteÃ§Ã£o de rotas
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ agent_routes.py   # Rotas relacionadas ao agente de IA
â”‚       â”œâ”€â”€ review_agent_routes.py # Rotas relacionadas ao agente de revisÃ£o
â”‚       â””â”€â”€ data_analysis_routes.py # Rotas de anÃ¡lise de dados
â”œâ”€â”€ models/                   # DefiniÃ§Ãµes de modelos de dados
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ flow.py
â”‚   â””â”€â”€ review_models.py
â””â”€â”€ services/                 # LÃ³gica de negÃ³cio e serviÃ§os
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ langchain_agent_service.py
    â”œâ”€â”€ memory_service.py
    â”œâ”€â”€ enhanced_memory_service.py  # âœ… CORRIGIDO
    â”œâ”€â”€ review_agent_service.py
    â”œâ”€â”€ backlog_generator_service.py
    â”œâ”€â”€ sentiment_analysis_service.py
    â””â”€â”€ ... (outros serviÃ§os)
```

## ğŸš€ Como Executar Localmente

### PrÃ©-requisitos

- Python 3.11+
- `pip` (gerenciador de pacotes Python)

### InstalaÃ§Ã£o e ExecuÃ§Ã£o

1. **Clone o repositÃ³rio**:

   ```bash
   git clone https://github.com/cledsondevs/iara-flow-bff.git
   cd iara-flow-bff
   ```

2. **Instale as dependÃªncias**:

   ```bash
   pip install -r requirements.txt
   ```

3. **Configure as variÃ¡veis de ambiente** (crie um arquivo `.env`):

   ```env
   SECRET_KEY=sua_chave_secreta_aqui
   DB_PATH=./iara_flow.db
   OPENAI_API_KEY=sua_chave_openai_aqui
   GEMINI_API_KEY=sua_chave_gemini_aqui
   FLASK_ENV=development
   PORT=5000
   DEBUG=true
   ```

4. **Execute a aplicaÃ§Ã£o**:

   ```bash
   python app/main.py
   ```

5. **Acesse a aplicaÃ§Ã£o**:
   - URL: `http://localhost:5000`
   - Health Check: `http://localhost:5000/` (deve retornar `{"status": "ok", "message": "Iara Flow BFF is running"}`)

### ğŸ§ª Testando o Endpoint Corrigido

O endpoint que estava com erro agora funciona corretamente:

```bash
# Teste do endpoint de geraÃ§Ã£o de backlog
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"days": 7}' \
  http://localhost:5000/api/review-agent/apps/com.tau.investimentos/backlog
```

**Resposta esperada**: JSON com backlog gerado e otimizaÃ§Ãµes aplicadas.

## ğŸ“Š Funcionalidade de Dashboards Gerenciais

Uma nova funcionalidade de dashboards gerenciais foi adicionada, permitindo a visualizaÃ§Ã£o personalizada dos dados do backlog.

### GeraÃ§Ã£o de Dashboards

Os dashboards podem ser gerados de duas formas:

1.  **Automaticamente com a GeraÃ§Ã£o de Backlog**:
    Ao chamar o endpoint de geraÃ§Ã£o de backlog, um dashboard serÃ¡ criado automaticamente se a flag `generate_dashboard` for `True` (padrÃ£o).

    ```bash
    curl -X POST \
      -H "Content-Type: application/json" \
      -d '{"package_name": "com.example.app", "days": 7, "generate_dashboard": true}' \
      http://localhost:5000/api/review-agent/apps/com.example.app/backlog
    ```

    A resposta incluirÃ¡ um campo `dashboard` com a `custom_url` para acesso.

2.  **Via Endpoint Dedicado**:
    VocÃª pode gerar um dashboard diretamente, fornecendo os dados do backlog (ou deixando o backend gerÃ¡-los).
    ```bash
    curl -X POST \
      -H "Content-Type: application/json" \
      -d '{"package_name": "com.example.app", "days": 7, "user_id": "user123", "session_id": "session456"}' \
      http://localhost:5000/api/dashboard/generate
    ```

### VisualizaÃ§Ã£o de Dashboards

Para visualizar um dashboard, acesse a URL personalizada gerada:

```
http://localhost:5000/api/dashboard/{custom_url}
```

Exemplo:

```
http://localhost:5000/api/dashboard/dashboard-com-example-test-202507220801-d944f9a4-150d28ee
```

### Endpoints de Dashboard

- `POST /api/dashboard/generate` - Gerar um novo dashboard.
- `GET /api/dashboard/{custom_url}` - Visualizar um dashboard especÃ­fico.
- `GET /api/dashboard/list` - Listar todos os dashboards criados.
- `GET /api/dashboard/stats` - Obter estatÃ­sticas gerais sobre os dashboards.
- `POST /api/dashboard/preview` - Gerar um preview de dashboard sem salvÃ¡-lo.
- `DELETE /api/dashboard/{dashboard_id}` - Deletar um dashboard (soft delete).
- `POST /api/dashboard/cleanup` - Limpar dashboards expirados.

### Frontend de VisualizaÃ§Ã£o (React)

Para uma experiÃªncia de visualizaÃ§Ã£o mais rica, vocÃª pode usar o frontend React desenvolvido para consumir esses dashboards. Ele estÃ¡ disponÃ­vel em outro repositÃ³rio:

[https://github.com/cledsondevs/iara-flow-prototyper](https://github.com/cledsondevs/iara-flow-prototyper)

**Como executar o frontend (apÃ³s clonar o repositÃ³rio `iara-flow-prototyper`):**

1.  **Instale as dependÃªncias**:

    ```bash
    cd iara-flow-prototyper
    pnpm install
    ```

2.  **Inicie o servidor de desenvolvimento**:

    ```bash
    pnpm run dev --host 0.0.0.0
    ```

3.  **Acesse no navegador**:
    Normalmente em `http://localhost:5173` ou outra porta disponÃ­vel.

## Principais Melhorias e Funcionalidades

### 1. Estrutura Modularizada

- **SeparaÃ§Ã£o de Responsabilidades**: Cada mÃ³dulo tem uma funÃ§Ã£o especÃ­fica, tornando o cÃ³digo mais organizado e fÃ¡cil de entender.
- **ManutenÃ§Ã£o e Escalabilidade**: A nova estrutura facilita a adiÃ§Ã£o de novas funcionalidades e a manutenÃ§Ã£o do cÃ³digo existente.

### 2. ConfiguraÃ§Ãµes Centralizadas

- O arquivo `app/config/settings.py` centraliza todas as configuraÃ§Ãµes da aplicaÃ§Ã£o, incluindo chaves secretas, caminhos de banco de dados e configuraÃ§Ãµes de ambiente (desenvolvimento/produÃ§Ã£o).

### 3. Sistema de AutenticaÃ§Ã£o Completo e Corrigido

- **Rotas de AutenticaÃ§Ã£o**: Inclui rotas para registro (`/api/auth/register`), login (`/api/auth/login`), logout (`/api/auth/logout`), verificaÃ§Ã£o de sessÃ£o (`/api/auth/verify`) e obtenÃ§Ã£o de informaÃ§Ãµes de usuÃ¡rio (`/api/auth/user/<id>`).
- **CorreÃ§Ã£o do Erro 405**: O problema de acesso Ã s rotas de autenticaÃ§Ã£o (erro 405) foi resolvido garantindo que o `auth_bp` (Blueprint de autenticaÃ§Ã£o) seja corretamente registrado na aplicaÃ§Ã£o principal.
- **Middleware de AutenticaÃ§Ã£o**: Rotas sensÃ­veis sÃ£o protegidas por um middleware (`@require_auth`) que verifica a validade do token de sessÃ£o.

### 4. API para Listar UsuÃ¡rios

- **Nova Rota**: Adicionada a rota `GET /api/auth/users` que permite listar todos os usuÃ¡rios cadastrados no banco de dados.
- **ProteÃ§Ã£o**: Esta rota Ã© protegida por autenticaÃ§Ã£o, exigindo um token de sessÃ£o vÃ¡lido.

### 5. UtilitÃ¡rios de Banco de Dados

- FunÃ§Ãµes centralizadas em `app/utils/database.py` para gerenciar a conexÃ£o com o SQLite e inicializar as tabelas necessÃ¡rias.

### 6. Sistema de MemÃ³ria Aprimorado âœ…

- **Enhanced Memory Service**: ServiÃ§o de memÃ³ria com funcionalidades avanÃ§adas para anÃ¡lise de reviews
- **OtimizaÃ§Ã£o de Backlog**: Algoritmos inteligentes para priorizaÃ§Ã£o e otimizaÃ§Ã£o de itens de backlog
- **AnÃ¡lise de TendÃªncias**: Monitoramento de tendÃªncias de sentimento ao longo do tempo

## ğŸ“‹ Endpoints Principais

### AutenticaÃ§Ã£o

- `POST /api/auth/register` - Registro de usuÃ¡rio
- `POST /api/auth/login` - Login
- `POST /api/auth/logout` - Logout
- `POST /api/auth/verify` - VerificaÃ§Ã£o de sessÃ£o
- `GET /api/auth/users` - Listar usuÃ¡rios

### Review Agent

- `GET /api/review-agent/health` - Health check do agente
- `POST /api/review-agent/apps/<package_name>/backlog` - âœ… **CORRIGIDO** - Gerar backlog
- `POST /api/review-agent/apps/<package_name>/analyze` - Analisar sentimento
- `GET /api/review-agent/apps/<package_name>/dashboard` - Dashboard do app

### Dashboards Gerenciais

- `POST /api/dashboard/generate` - Gerar um novo dashboard. Exemplo de uso:
  ```bash
  curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"package_name": "com.example.app", "days": 7, "user_id": "user123", "session_id": "session456"}' \
    http://localhost:5000/api/dashboard/generate
  ```
- `GET /api/dashboard/{custom_url}` - Visualizar um dashboard especÃ­fico. Exemplo de uso:
  ```bash
  curl http://localhost:5000/api/dashboard/dashboard-com-example-test-202507220801-d944f9a4-150d28ee
  ```
- `GET /api/dashboard/list` - Listar todos os dashboards criados. Exemplo de uso:
  ```bash
  curl http://localhost:5000/api/dashboard/list?package_name=com.example.app
  ```
- `GET /api/dashboard/stats` - Obter estatÃ­sticas gerais sobre os dashboards. Exemplo de uso:
  ```bash
  curl http://localhost:5000/api/dashboard/stats
  ```
- `POST /api/dashboard/preview` - Gerar um preview de dashboard sem salvÃ¡-lo. Exemplo de uso:
  ```bash
  curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"package_name": "com.example.app", "days": 7}' \
    http://localhost:5000/api/dashboard/preview
  ```
- `DELETE /api/dashboard/{dashboard_id}` - Deletar um dashboard (soft delete). Exemplo de uso:
  ```bash
  curl -X DELETE http://localhost:5000/api/dashboard/SEU_DASHBOARD_ID
  ```
- `POST /api/dashboard/cleanup` - Limpar dashboards expirados. Exemplo de uso:
  ```bash
  curl -X POST http://localhost:5000/api/dashboard/cleanup
  ```

## Testes Realizados

Durante o desenvolvimento e correÃ§Ãµes, os seguintes endpoints foram testados:

- âœ… **Health Check**: `GET /`
- âœ… **Registro de UsuÃ¡rio**: `POST /api/auth/register`
- âœ… **Login de UsuÃ¡rio**: `POST /api/auth/login`
- âœ… **VerificaÃ§Ã£o de SessÃ£o**: `POST /api/auth/verify`
- âœ… **ObtenÃ§Ã£o de InformaÃ§Ãµes do UsuÃ¡rio**: `GET /api/auth/user/{id}`
- âœ… **Listagem de UsuÃ¡rios**: `GET /api/auth/users`
- âœ… **GeraÃ§Ã£o de Backlog**: `POST /api/review-agent/apps/<package_name>/backlog` **[CORRIGIDO]**

### UsuÃ¡rio de Teste PadrÃ£o

Um usuÃ¡rio de teste Ã© criado/utilizado nos testes automatizados:

- **Username**: `usuario_teste`
- **Password**: `senha123`
- **Email**: `teste@exemplo.com`

## Deploy em Servidor (Gunicorn/Systemd)

Para deploy em um servidor de produÃ§Ã£o utilizando Gunicorn e Systemd, certifique-se de que:

1.  **`wsgi.py` estÃ¡ configurado corretamente**: O arquivo `wsgi.py` deve apontar para a instÃ¢ncia da aplicaÃ§Ã£o Flask em `app.main:create_app()`.
    Exemplo de `wsgi.py`:

    ```python
    import sys
    import os

    sys.path.insert(0, os.path.dirname(__file__))

    from app.main import create_app

    application = create_app()
    ```

2.  **ServiÃ§o Systemd aponta para o `wsgi:application`**: A configuraÃ§Ã£o do seu serviÃ§o `.service` (ex: `/etc/systemd/system/iara-flow-bff.service`) deve ter a linha `ExecStart` apontando para `wsgi:application`.
    Exemplo de `ExecStart`:

    ```
    ExecStart=/caminho/para/seu/venv/bin/gunicorn --workers 3 --bind 0.0.0.0:5000 wsgi:application
    ```

3.  **Recarregue e Reinicie o ServiÃ§o**: ApÃ³s qualquer alteraÃ§Ã£o nos arquivos de configuraÃ§Ã£o ou cÃ³digo, execute:
    ```bash
    sudo systemctl daemon-reload
    sudo systemctl restart iara-flow-bff
    ```

## ğŸ”„ HistÃ³rico de Branches

- **`main`**: Branch principal com cÃ³digo estÃ¡vel
- **`fix-optimize-backlog-generation`**: âœ… **NOVA BRANCH** - CorreÃ§Ã£o do mÃ©todo `optimize_backlog_generation`
- **`feat-dashboard-integration`**: âœ… **NOVA BRANCH** - AdiÃ§Ã£o da funcionalidade de dashboards gerenciais

## PrÃ³ximos Passos Sugeridos

1.  **Testes UnitÃ¡rios Abrangentes**: Implementar testes unitÃ¡rios mais detalhados para cada mÃ³dulo e funÃ§Ã£o.
2.  **DocumentaÃ§Ã£o da API (Swagger/OpenAPI)**: Gerar uma documentaÃ§Ã£o interativa da API para facilitar o consumo por outros serviÃ§os ou frontends.
3.  **Sistema de Logging Estruturado**: Implementar um sistema de logging mais robusto para monitoramento e depuraÃ§Ã£o em produÃ§Ã£o.
4.  **ValidaÃ§Ã£o de Dados**: Utilizar bibliotecas como `Marshmallow` ou `Pydantic` para validaÃ§Ã£o de dados de entrada e saÃ­da.
5.  **Cache**: Implementar estratÃ©gias de cache para melhorar a performance de endpoints frequentemente acessados.
6.  **Monitoramento**: Adicionar mÃ©tricas e health checks avanÃ§ados para monitorar a saÃºde da aplicaÃ§Ã£o em tempo real.

## ContribuiÃ§Ã£o

Sinta-se Ã  vontade para contribuir com o projeto! Para isso:

1.  Crie uma nova branch a partir da branch principal.
2.  FaÃ§a suas alteraÃ§Ãµes e adicione novos testes, se aplicÃ¡vel.
3.  Teste suas alteraÃ§Ãµes localmente.
4.  Crie um Pull Request descrevendo suas modificaÃ§Ãµes.

---

**Ãšltima atualizaÃ§Ã£o**: 22/07/2025 - CorreÃ§Ã£o do mÃ©todo `optimize_backlog_generation` e AdiÃ§Ã£o da funcionalidade de Dashboards Gerenciais

## ğŸ§  Funcionalidade de MemÃ³ria do Agente (Gemini)

O backend agora suporta um sistema de memÃ³ria para os agentes conversacionais, permitindo que eles mantenham o contexto da conversa ao longo do tempo. Isso Ã© crucial para interaÃ§Ãµes mais naturais e coerentes.

### Como Funciona

1.  **`user_id`**: Cada usuÃ¡rio Ã© identificado por um `user_id` Ãºnico. Este ID Ã© usado para associar o histÃ³rico de conversas a um usuÃ¡rio especÃ­fico.
2.  **`session_id`**: Dentro de cada interaÃ§Ã£o do usuÃ¡rio, um `session_id` Ã© utilizado para agrupar mensagens que fazem parte da mesma sessÃ£o de conversa.
3.  **PersistÃªncia**: O histÃ³rico da conversa (mensagens do usuÃ¡rio e respostas do agente) Ã© salvo no banco de dados (SQLite) associado ao `user_id` e `session_id`.
4.  **RecuperaÃ§Ã£o**: Antes de processar uma nova mensagem, o agente recupera o histÃ³rico recente da conversa usando o `user_id` e `session_id` fornecidos. Isso permite que o modelo de linguagem (ex: Gemini) tenha acesso ao contexto anterior para gerar respostas relevantes.

### BenefÃ­cios

- **CoerÃªncia da Conversa**: O agente se lembra do que foi dito anteriormente, evitando repetiÃ§Ãµes e fornecendo respostas mais precisas.
- **PersonalizaÃ§Ã£o**: A interaÃ§Ã£o se torna mais personalizada, pois o agente tem conhecimento do histÃ³rico individual de cada usuÃ¡rio.
- **Continuidade**: Permite que as conversas sejam retomadas de onde pararam, mesmo apÃ³s um perÃ­odo de inatividade ou em sessÃµes diferentes.

### ImplementaÃ§Ã£o

A lÃ³gica de persistÃªncia e recuperaÃ§Ã£o da memÃ³ria estÃ¡ implementada principalmente nos serviÃ§os `memory_service.py` e `gemini_agent_service.py`.

Ao chamar o endpoint `/gemini/chat`, certifique-se de fornecer o `user_id` e, opcionalmente, o `session_id` para garantir que o histÃ³rico seja corretamente gerenciado:

````json
{
  "message": "OlÃ¡, tudo bem?",
  "user_id": "seu_user_id_aqui",
  "session_id": "seu_session_id_aqui",
  "api_key": "sua_chave_api_gemini_aqui"
}


## ğŸ§  Como o LangChain Aprende AtravÃ©s de Conversas

O coraÃ§Ã£o de qualquer agente de IA conversacional eficaz reside na sua capacidade de "lembrar" o que foi dito anteriormente. Sem essa funcionalidade, cada interaÃ§Ã£o seria um novo comeÃ§o, resultando em respostas genÃ©ricas, repetitivas e, em Ãºltima anÃ¡lise, uma experiÃªncia de usuÃ¡rio frustrante. No Iara Flow BFF, utilizamos o framework LangChain em conjunto com um serviÃ§o de memÃ³ria persistente baseado em SQLite para dotar nossos agentes com essa capacidade crucial de aprendizado e contextualizaÃ§Ã£o.

### O Conceito de MemÃ³ria no LangChain

No ecossistema LangChain, a memÃ³ria Ã© o componente responsÃ¡vel por preservar o estado de uma conversa. Isso permite que os Large Language Models (LLMs) como o Gemini, que sÃ£o inerentemente "sem estado" (ou seja, nÃ£o retÃªm informaÃ§Ãµes de interaÃ§Ãµes passadas por padrÃ£o), possam acessar o histÃ³rico da conversa e gerar respostas que sÃ£o contextualmente relevantes. Existem diversos tipos de memÃ³ria no LangChain, desde buffers simples que armazenam as Ãºltimas N interaÃ§Ãµes atÃ© memÃ³rias mais complexas que utilizam embeddings para recuperar informaÃ§Ãµes semanticamente similares.

No nosso projeto, a implementaÃ§Ã£o da memÃ³ria Ã© realizada atravÃ©s do `MemoryService`, que atua como uma camada de abstraÃ§Ã£o sobre o banco de dados SQLite. Cada turno da conversa (mensagem do usuÃ¡rio e resposta do agente) Ã© salvo de forma estruturada, permitindo que o agente recupere esse histÃ³rico quando necessÃ¡rio.

### Mecanismo de Aprendizado e ContextualizaÃ§Ã£o

O processo pelo qual o LangChain "aprende" e mantÃ©m o contexto das conversas no Iara Flow BFF pode ser detalhado em algumas etapas:

1.  **Captura da InteraÃ§Ã£o**: Sempre que um usuÃ¡rio envia uma mensagem para o agente de IA, e o agente gera uma resposta, essa dupla (mensagem do usuÃ¡rio, resposta do agente) Ã© capturada pelo sistema.

2.  **PersistÃªncia no SQLite**: O `MemoryService` Ã© invocado para salvar essa interaÃ§Ã£o no banco de dados SQLite. Cada registro inclui o `user_id` (identificador Ãºnico do usuÃ¡rio), o `session_id` (identificador da sessÃ£o de conversa atual), a mensagem do usuÃ¡rio, a resposta do agente, e um timestamp. A inclusÃ£o do `session_id` Ã© fundamental, pois permite que um mesmo usuÃ¡rio tenha mÃºltiplas conversas independentes, ou que uma conversa seja retomada em diferentes momentos, mantendo seu prÃ³prio contexto.

3.  **RecuperaÃ§Ã£o do HistÃ³rico**: Antes de processar uma nova mensagem do usuÃ¡rio, o `LangChainAgentService` consulta o `MemoryService` para recuperar o histÃ³rico de conversas relevante. Essa recuperaÃ§Ã£o Ã© feita com base no `user_id` e no `session_id` fornecidos na requisiÃ§Ã£o. Por padrÃ£o, um nÃºmero limitado de interaÃ§Ãµes mais recentes Ã© recuperado para manter a relevÃ¢ncia e evitar sobrecarga do contexto.

4.  **InjeÃ§Ã£o de Contexto no LLM**: O histÃ³rico de conversas recuperado Ã© entÃ£o formatado de uma maneira que o modelo de linguagem (LLM) entenda. No caso do LangChain, isso geralmente envolve a conversÃ£o das mensagens em objetos `HumanMessage` e `AIMessage`, que representam as falas do usuÃ¡rio e do assistente, respectivamente. Esse histÃ³rico formatado Ã© passado como parte do prompt para o LLM. Ã‰ como se o agente estivesse lendo as Ãºltimas pÃ¡ginas de um livro antes de continuar a histÃ³ria.

5.  **GeraÃ§Ã£o de Resposta Contextualizada**: Com o histÃ³rico da conversa em mÃ£os, o LLM Ã© capaz de gerar uma resposta que nÃ£o apenas aborda a mensagem atual do usuÃ¡rio, mas tambÃ©m leva em consideraÃ§Ã£o o que foi discutido anteriormente. Isso resulta em interaÃ§Ãµes mais fluidas, naturais e inteligentes, onde o agente demonstra compreensÃ£o do fluxo da conversa.

### ImportÃ¢ncia da MemÃ³ria

A memÃ³ria Ã© vital para:

*   **CoerÃªncia e Continuidade**: Garante que o agente mantenha o fio da meada, evitando que ele se contradiga ou peÃ§a informaÃ§Ãµes jÃ¡ fornecidas.
*   **PersonalizaÃ§Ã£o**: Permite que o agente adapte suas respostas com base nas preferÃªncias ou informaÃ§Ãµes previamente compartilhadas pelo usuÃ¡rio.
*   **EficiÃªncia**: Reduz a necessidade de o usuÃ¡rio repetir informaÃ§Ãµes, tornando a interaÃ§Ã£o mais eficiente e menos cansativa.
*   **ExperiÃªncia do UsuÃ¡rio Aprimorada**: Transforma um chatbot simples em um assistente verdadeiramente conversacional, capaz de engajar em diÃ¡logos complexos e de longo prazo.

Em resumo, a funcionalidade de memÃ³ria implementada no Iara Flow BFF Ã© a espinha dorsal para a criaÃ§Ã£o de agentes de IA que nÃ£o apenas respondem, mas realmente interagem e aprendem com cada conversa, proporcionando uma experiÃªncia de usuÃ¡rio superior.



## ğŸ§¹ Como Limpar o HistÃ³rico de Conversas via API

Manter o histÃ³rico de conversas Ã© essencial para a coerÃªncia e personalizaÃ§Ã£o das interaÃ§Ãµes com o agente de IA. No entanto, em certos cenÃ¡rios, pode ser necessÃ¡rio limpar esse histÃ³rico. Isso pode ser Ãºtil para iniciar uma nova conversa do zero, para fins de privacidade, ou para depuraÃ§Ã£o. O Iara Flow BFF oferece um endpoint especÃ­fico para gerenciar a limpeza da memÃ³ria do agente.

### Endpoint de Limpeza de MemÃ³ria

O mÃ©todo `clear_memory` no `LangChainAgentService` Ã© responsÃ¡vel por orquestrar a limpeza do histÃ³rico de conversas. Ele utiliza o `MemoryService` para interagir diretamente com o banco de dados SQLite e remover os registros de conversa.

VocÃª pode limpar o histÃ³rico de conversas de um usuÃ¡rio ou de uma sessÃ£o especÃ­fica atravÃ©s do seguinte endpoint:

*   **`POST /api/gemini/clear-memory`**

Este endpoint aceita um corpo de requisiÃ§Ã£o JSON com os seguintes parÃ¢metros:

*   **`user_id`** (obrigatÃ³rio): O identificador Ãºnico do usuÃ¡rio cujo histÃ³rico de conversas serÃ¡ limpo.
*   **`session_id`** (opcional): O identificador da sessÃ£o especÃ­fica a ser limpa. Se este parÃ¢metro for fornecido, apenas o histÃ³rico daquela sessÃ£o para o `user_id` especificado serÃ¡ removido. Se `session_id` nÃ£o for fornecido, **todo o histÃ³rico de conversas** para o `user_id` serÃ¡ limpo.

### Exemplos de Uso

#### 1. Limpar o histÃ³rico de uma sessÃ£o especÃ­fica

Para limpar apenas o histÃ³rico de uma sessÃ£o de conversa especÃ­fica para um determinado usuÃ¡rio, inclua ambos `user_id` e `session_id` na sua requisiÃ§Ã£o:

```json
{
  "user_id": "seu_user_id_aqui",
  "session_id": "seu_session_id_aqui"
}
````

**Exemplo de `curl`:**

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"user_id": "usuario123", "session_id": "sessaoABC"}' \
  http://localhost:5000/api/gemini/clear-memory
```

#### 2. Limpar todo o histÃ³rico de um usuÃ¡rio

Para limpar todo o histÃ³rico de conversas de um usuÃ¡rio (todas as sessÃµes associadas a ele), forneÃ§a apenas o `user_id` na sua requisiÃ§Ã£o:

```json
{
  "user_id": "seu_user_id_aqui"
}
```

**Exemplo de `curl`:**

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"user_id": "usuario123"}' \
  http://localhost:5000/api/gemini/clear-memory
```

### ConsideraÃ§Ãµes Importantes

- **Irreversibilidade**: A limpeza do histÃ³rico de conversas Ã© uma operaÃ§Ã£o irreversÃ­vel. Uma vez que os dados sÃ£o removidos do banco de dados, eles nÃ£o podem ser recuperados.
- **Impacto na CoerÃªncia**: Limpar o histÃ³rico de uma sessÃ£o farÃ¡ com que o agente "esqueÃ§a" o contexto anterior para aquela sessÃ£o, iniciando uma nova conversa do zero. Limpar todo o histÃ³rico de um usuÃ¡rio terÃ¡ o mesmo efeito para todas as suas interaÃ§Ãµes futuras.
- **SeguranÃ§a**: Certifique-se de que o acesso a este endpoint seja devidamente protegido (por exemplo, atravÃ©s de autenticaÃ§Ã£o e autorizaÃ§Ã£o) para evitar a exclusÃ£o indevida de dados de conversas.

Esta funcionalidade oferece flexibilidade para gerenciar a memÃ³ria do agente de acordo com as necessidades da aplicaÃ§Ã£o e as preferÃªncias do usuÃ¡rio, garantindo tanto a privacidade quanto a capacidade de reiniciar interaÃ§Ãµes quando desejado.

```

O `session_id` pode ser gerado no frontend ou no backend, dependendo da sua estratÃ©gia de gerenciamento de sessÃ£o. Se nÃ£o for fornecido, um novo `session_id` pode ser gerado ou o Ãºltimo `session_id` do `user_id` pode ser utilizado para continuar a conversa.

```





---

# Changelog

Todas as mudanÃ§as notÃ¡veis neste projeto serÃ£o documentadas neste arquivo.

O formato Ã© baseado em [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
e este projeto adere ao [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- **Sistema de MemÃ³ria Isolado V2 (PersistÃªncia por UsuÃ¡rio)**
  - ImplementaÃ§Ã£o de um sistema de memÃ³ria completamente novo e isolado, garantindo persistÃªncia de conversas por `user_id` (independente da `session_id`).
  - **Novas Rotas API V2 para Chat Gemini:**
    - `POST /api/v2/chat/gemini` - Chat principal com memÃ³ria persistente.
    - `GET /api/v2/chat/gemini/memory` - Recupera todo o histÃ³rico de memÃ³ria do usuÃ¡rio.
    - `DELETE /api/v2/chat/gemini/memory` - Limpa toda a memÃ³ria do usuÃ¡rio.
    - `GET /api/v2/chat/gemini/stats` - ObtÃ©m estatÃ­sticas de uso da memÃ³ria do usuÃ¡rio.
    - `PUT /api/v2/chat/gemini/profile` - Atualiza o perfil do usuÃ¡rio.
    - `POST /api/v2/chat/gemini/fact` - Salva fatos especÃ­ficos sobre o usuÃ¡rio.
    - `GET /api/v2/chat/gemini/context` - ObtÃ©m o contexto completo da conversa do usuÃ¡rio.
    - `GET /api/v2/chat/health` - Health check para o serviÃ§o V2.
    - `POST /api/v2/chat/migrate` - Endpoint para futuras migraÃ§Ãµes de dados.
  - **PersistÃªncia de HistÃ³rico por `user_id`:**
    - A funÃ§Ã£o `get_conversation_history_isolated` no `IsolatedMemoryService` agora busca o histÃ³rico apenas por `user_id`, ignorando a `session_id`.
    - O `GeminiChatServiceV2` foi ajustado para utilizar este histÃ³rico expandido para construir o contexto da conversa.
  - **Comandos de MemÃ³ria Aprimorados:**
    - A funcionalidade "Lembre-se disso:" agora utiliza o novo sistema de memÃ³ria isolado, garantindo que os fatos sejam persistidos por `user_id`.

### Removed
- **CÃ³digo da VersÃ£o 1 (V1) do Sistema de MemÃ³ria e Chat:**
  - `app/chats/routes/chat_routes.py` (Rotas de chat V1).
  - `app/services/memory_service.py` (ServiÃ§o de memÃ³ria V1).
  - `app/services/enhanced_memory_service.py` (ServiÃ§o de memÃ³ria aprimorado V1).
  - `app/chats/services/gemini_chat_service.py` (ServiÃ§o de chat Gemini V1).
  - Todas as importaÃ§Ãµes e registros relacionados Ã  V1 foram removidos do `app/main.py`.

### Fixed
- **Problemas crÃ­ticos de salvamento e acesso de memÃ³rias resolvidos**
  - Corrigidos problemas de DEFAULT (lower(hex(randomblob(16)))) em todas as tabelas
  - Removidas expressÃµes SQL incompatÃ­veis que causavam erros de criaÃ§Ã£o de tabelas
  - Corrigidos arquivos: `backlog_generator_service.py`, `dashboard_service.py`, `review_collector_service.py`
  - Sistema de memÃ³ria de curto e longo prazo agora funciona corretamente
  - Conversas sÃ£o salvas e recuperadas adequadamente

- **Dados padrÃ£o implementados no banco de dados**
  - Criado script `create_sample_data.py` para popular o banco com dados de exemplo
  - Inseridos 3 usuÃ¡rios padrÃ£o: admin, demo_user, test_user
  - Criadas 3 conversas de exemplo com sistema de memÃ³ria funcionando
  - Inseridos 3 reviews de exemplo para testes
  - Banco de dados nÃ£o fica mais vazio apÃ³s inicializaÃ§Ã£o

- **Problema crÃ­tico de bloqueio do banco de dados SQLite resolvido**
  - Implementado gerenciamento adequado de conexÃµes usando context managers
  - Corrigidas todas as funÃ§Ãµes de autenticaÃ§Ã£o para usar `with get_db_connection()`
  - Eliminados vazamentos de conexÃ£o que causavam bloqueios
  - Adicionado script `fix_database_lock.py` para diagnÃ³stico e correÃ§Ã£o de bloqueios

- **APIs de Login totalmente funcionais**
  - Corrigidas rotas de autenticaÃ§Ã£o com prefixos incorretos
  - Resolvido erro "405 METHOD NOT ALLOWED" 
  - Todas as rotas de autenticaÃ§Ã£o agora funcionam corretamente:
    - `POST /api/auth/register` - Registro de usuÃ¡rios
    - `POST /api/auth/login` - Login de usuÃ¡rios  
    - `POST /api/auth/logout` - Logout de usuÃ¡rios
    - `POST /api/auth/verify` - VerificaÃ§Ã£o de sessÃ£o
    - `GET /api/auth/user/<id>` - Obter dados do usuÃ¡rio

- **Sistema de configuraÃ§Ã£o de chaves de API restaurado**
  - Corrigidas rotas de API keys: `POST /api/keys` e `GET /api/keys/<user_id>/<service_name>`
  - Adicionados imports necessÃ¡rios no arquivo `api_key_routes.py`
  - Sistema de armazenamento e recuperaÃ§Ã£o de chaves funcionando

- **Tabelas de memÃ³ria de longo prazo criadas corretamente**
  - Corrigida criaÃ§Ã£o automÃ¡tica das tabelas `conversations` e `user_profiles`
  - MemoryService agora usa configuraÃ§Ã£o centralizada do banco
  - CriaÃ§Ã£o automÃ¡tica do diretÃ³rio `data/` se nÃ£o existir
  - SincronizaÃ§Ã£o entre todos os serviÃ§os de banco de dados

- **ConfiguraÃ§Ã£o de banco de dados unificada**
  - Unificada configuraÃ§Ã£o em `Config.DATABASE_PATH`
  - ConsistÃªncia entre todos os arquivos (`auth_routes.py`, `memory_service.py`, `database.py`)
  - CriaÃ§Ã£o automÃ¡tica de diretÃ³rios em todos os pontos de acesso

- **UsuÃ¡rio padrÃ£o criado automaticamente**
  - CriaÃ§Ã£o automÃ¡tica de usuÃ¡rio administrador na inicializaÃ§Ã£o
  - **Credenciais:** `admin` / `admin` (email: `admin@iaraflow.com`)
  - Script independente `create_default_user.py` para criaÃ§Ã£o manual

- **DependÃªncias instaladas e configuradas**
  - Instaladas todas as dependÃªncias necessÃ¡rias: Flask, LangChain, Google AI, etc.
  - AplicaÃ§Ã£o Flask inicializa corretamente sem erros de mÃ³dulos
  - Todas as funcionalidades principais testadas e funcionando

### Technical Details
- Implementado padrÃ£o de context manager para conexÃµes SQLite
- Eliminados bloqueios de banco atravÃ©s de gerenciamento adequado de recursos
- Corrigidas estruturas try/except aninhadas que causavam problemas de sintaxe
- Adicionado tratamento robusto de erros em todas as operaÃ§Ãµes de banco

### Testing
- âœ… Login com usuÃ¡rio padrÃ£o (admin/admin) funcionando
- âœ… Registro de novos usuÃ¡rios funcionando  
- âœ… VerificaÃ§Ã£o de sessÃ£o funcionando
- âœ… ObtenÃ§Ã£o de dados de usuÃ¡rio funcionando
- âœ… ConfiguraÃ§Ã£o de chaves de API funcionando
- âœ… RecuperaÃ§Ã£o de chaves de API funcionando
- âœ… Banco de dados sem bloqueios
  - CriaÃ§Ã£o automÃ¡tica do diretÃ³rio `data/` se nÃ£o existir
  - Tabelas `conversations` e `user_profiles` criadas corretamente na inicializaÃ§Ã£o
  - SincronizaÃ§Ã£o entre `init_database()` e `MemoryService._init_sqlite_tables()`

- **ConfiguraÃ§Ã£o de Banco de Dados**: Unificada configuraÃ§Ã£o de caminho do banco
  - Todos os serviÃ§os agora usam `Config.DATABASE_PATH` ao invÃ©s de caminhos hardcoded
  - CriaÃ§Ã£o automÃ¡tica do diretÃ³rio do banco em todos os pontos de acesso
  - ConsistÃªncia entre `auth_routes.py`, `memory_service.py` e `database.py`

### Added
- **UsuÃ¡rio PadrÃ£o**: CriaÃ§Ã£o automÃ¡tica de usuÃ¡rio administrador na inicializaÃ§Ã£o
  - Username: `admin`
  - Password: `admin`
  - Email: `admin@iaraflow.com`
  - Criado automaticamente se nÃ£o existir durante a inicializaÃ§Ã£o da aplicaÃ§Ã£o
  - Script independente `create_default_user.py` para criaÃ§Ã£o manual

### Changed
- **InicializaÃ§Ã£o da AplicaÃ§Ã£o**: Melhorada sequÃªncia de inicializaÃ§Ã£o
  - Banco de dados inicializado primeiro
  - MemoryService inicializado em seguida
  - UsuÃ¡rio padrÃ£o criado automaticamente
  - Logs informativos para cada etapa da inicializaÃ§Ã£o

### Technical Details
- **Arquivos modificados**:
  - `app/auth/auth_routes.py` - Corrigidas rotas e configuraÃ§Ã£o de banco
  - `app/services/memory_service.py` - Unificada configuraÃ§Ã£o de banco e criaÃ§Ã£o de diretÃ³rio
  - `app/main.py` - Adicionada criaÃ§Ã£o automÃ¡tica de usuÃ¡rio padrÃ£o
  - `app/utils/database.py` - Mantida consistÃªncia na configuraÃ§Ã£o

- **Arquivos criados**:
  - `create_default_user.py` - Script para criaÃ§Ã£o manual de usuÃ¡rio padrÃ£o

### Notes
- As APIs de autenticaÃ§Ã£o agora funcionam corretamente com os endpoints esperados
- O sistema de memÃ³ria de longo prazo estÃ¡ totalmente funcional
- UsuÃ¡rio padrÃ£o permite acesso imediato ao sistema apÃ³s instalaÃ§Ã£o
- Todas as configuraÃ§Ãµes de banco de dados estÃ£o centralizadas em `Config.DATABASE_PATH`

### Added
- **MemÃ³ria de Longo Prazo para Chats**: ImplementaÃ§Ã£o de sistema de memÃ³ria persistente para os endpoints de chat Gemini e OpenAI
  - Novo endpoint `/api/gemini/chat` com memÃ³ria de longo prazo
  - Novo endpoint `/api/openai/chat` com memÃ³ria de longo prazo
  - Endpoints para gerenciar memÃ³ria: GET e DELETE para `/api/gemini/memory` e `/api/openai/memory`
  - Endpoint de verificaÃ§Ã£o de saÃºde: `/api/chat/health`
  - Sistema de sessÃµes para isolar conversas por usuÃ¡rio e sessÃ£o
  - Armazenamento persistente de conversas no banco SQLite
  - Contexto de conversa mantido entre sessÃµes diferentes

- **MemÃ³ria de Longo Prazo para LangChain Agent**: ExtensÃ£o da funcionalidade de memÃ³ria persistente para o agente LangChain
  - Endpoint `/api/agent/chat` agora utiliza memÃ³ria de longo prazo
  - HistÃ³rico de conversas mantido entre reinicializaÃ§Ãµes do servidor
  - IntegraÃ§Ã£o com ferramentas (web_search, file operations) preservada
  - Metadados aprimorados incluindo ferramentas utilizadas e tipo de agente

- **Suporte ao Groq Chat**: Novo provedor de IA adicionado ao sistema de chat
  - Novo endpoint `/api/groq/chat` com memÃ³ria de longo prazo
  - Endpoints para gerenciar memÃ³ria: GET e DELETE para `/api/groq/memory`
  - Endpoint para listar modelos disponÃ­veis: `/api/groq/models`
  - Suporte a mÃºltiplos modelos Groq (llama3-8b-8192, llama3-70b-8192, mixtral-8x7b-32768, gemma-7b-it)
  - IntegraÃ§Ã£o completa com sistema de memÃ³ria unificado

- **MemÃ³ria Global por UsuÃ¡rio**: Sistema de perfil persistente que transcende sessÃµes individuais
  - Nova tabela `user_profiles` para armazenar informaÃ§Ãµes globais do usuÃ¡rio
  - ExtraÃ§Ã£o automÃ¡tica de informaÃ§Ãµes pessoais das mensagens (nome, profissÃ£o, idade)
  - Contexto do usuÃ¡rio incluÃ­do automaticamente em todas as conversas
  - Funciona em todos os provedores: Gemini, OpenAI, Groq e LangChain
  - Permite que o assistente "lembre" do usuÃ¡rio mesmo em sessÃµes diferentes

- **Funcionalidade "Lembre-se disso"**: Sistema de salvamento explÃ­cito de informaÃ§Ãµes pelo usuÃ¡rio
  - Palavras-chave para salvar fatos: "lembre-se disso:", "importante:", "salvar para depois:", "nÃ£o esqueÃ§a:", "anotar:", "lembrar:"
  - DetecÃ§Ã£o automÃ¡tica e extraÃ§Ã£o de fatos das mensagens do usuÃ¡rio
  - Fatos salvos sÃ£o incluÃ­dos automaticamente no contexto de futuras conversas
  - Funciona em todos os provedores de IA (Gemini, OpenAI, Groq, LangChain)
  - Limite de 10 fatos por usuÃ¡rio para otimizaÃ§Ã£o de performance
  - ConfirmaÃ§Ã£o visual quando um fato Ã© salvo (âœ… InformaÃ§Ã£o salva na memÃ³ria!)

### Changed
- Estrutura do projeto expandida com novos serviÃ§os de chat
- **LangChain Agent Service**: Refatorado para usar memÃ³ria persistente ao invÃ©s de memÃ³ria em tempo de execuÃ§Ã£o
  - Modelo atualizado para `gpt-4o-mini` (compatibilidade com API)
  - HistÃ³rico de conversa limitado a 20 mensagens para otimizaÃ§Ã£o
  - Ordem cronolÃ³gica corrigida para manter contexto adequado
- **Sistema de Chat**: Expandido para suportar quatro provedores de IA (Gemini, OpenAI, Groq, LangChain)
- **Endpoint de Health Check**: Atualizado para incluir todos os serviÃ§os disponÃ­veis
- **MemoryService**: Expandido com funcionalidades de perfil global por usuÃ¡rio e salvamento explÃ­cito
  - MÃ©todo `save_message_with_profile_update()` para extraÃ§Ã£o automÃ¡tica de informaÃ§Ãµes
  - MÃ©todo `get_user_context_for_chat()` para incluir contexto em conversas
  - MÃ©todo `extract_user_info_from_message()` para anÃ¡lise de mensagens
  - MÃ©todo `detect_and_save_user_fact()` para processamento de comandos "Lembre-se disso"
  - MÃ©todo `save_user_fact()` para salvamento de fatos especÃ­ficos
  - MÃ©todo `get_user_facts()` para recuperaÃ§Ã£o de fatos salvos
  - MÃ©todo `remove_user_fact()` para remoÃ§Ã£o de fatos especÃ­ficos
- **Todos os ServiÃ§os de Chat**: Atualizados para usar memÃ³ria global por usuÃ¡rio e funcionalidade "Lembre-se disso"
  - Processamento automÃ¡tico de palavras-chave para salvamento de fatos
  - ConfirmaÃ§Ã£o visual quando informaÃ§Ãµes sÃ£o salvas
  - Metadados aprimorados incluindo flag `fact_saved`
- Sistema de memÃ³ria aprimorado para suportar mÃºltiplos provedores de IA

### Technical Details
- **Novos arquivos criados**:
  - `src/services/gemini_chat_service.py` - ServiÃ§o para integraÃ§Ã£o com Google Gemini
  - `src/services/openai_chat_service.py` - ServiÃ§o para integraÃ§Ã£o com OpenAI
  - `src/services/groq_chat_service.py` - ServiÃ§o para integraÃ§Ã£o com Groq
  - `src/routes/chat_routes.py` - Rotas para endpoints de chat
  - `test_gemini_chat.py` - Script de teste para validaÃ§Ã£o do chat Gemini
  - `test_langchain_memory.py` - Script de teste para validaÃ§Ã£o da memÃ³ria do LangChain
  - `test_groq_chat.py` - Script de teste para validaÃ§Ã£o do chat Groq
  - `test_global_memory.py` - Script de teste para validaÃ§Ã£o da memÃ³ria global por usuÃ¡rio
  - `test_remember_this.py` - Script de teste para validaÃ§Ã£o da funcionalidade "Lembre-se disso"
  - `README_MEMORY_IMPLEMENTATION.md` - DocumentaÃ§Ã£o tÃ©cnica da implementaÃ§Ã£o

- **Arquivos modificados**:
  - `src/services/memory_service.py` - Adicionada funcionalidade de perfil global por usuÃ¡rio e "Lembre-se disso"
  - `src/services/langchain_agent_service.py` - IntegraÃ§Ã£o com memÃ³ria de longo prazo, global e "Lembre-se disso"
  - `src/services/gemini_chat_service.py` - IntegraÃ§Ã£o com memÃ³ria global por usuÃ¡rio e "Lembre-se disso"
  - `src/services/openai_chat_service.py` - IntegraÃ§Ã£o com memÃ³ria global por usuÃ¡rio e "Lembre-se disso"
  - `src/services/groq_chat_service.py` - IntegraÃ§Ã£o com memÃ³ria global por usuÃ¡rio e "Lembre-se disso"
  - `src/main.py` - Registro das novas rotas de chat
  - `.env` - ConfiguraÃ§Ã£o das chaves de API

- **DependÃªncias adicionadas**:
  - `google-generativeai` - SDK oficial do Google Gemini
  - `groq` - SDK oficial do Groq
  - ConfiguraÃ§Ã£o de variÃ¡veis de ambiente para `GEMINI_API_KEY` e `GROQ_API_KEY`

- **Funcionalidades implementadas**:
  - RecuperaÃ§Ã£o automÃ¡tica do histÃ³rico de conversas para todos os provedores
  - ConstruÃ§Ã£o de contexto para manter continuidade das conversas
  - Isolamento de sessÃµes por `user_id` e `session_id`
  - Metadados de uso e estatÃ­sticas para cada interaÃ§Ã£o
  - Tratamento de erros robusto em todos os serviÃ§os
  - Suporte a diferentes modelos OpenAI e Groq via parÃ¢metro opcional
  - IntegraÃ§Ã£o transparente do LangChain com ferramentas e memÃ³ria persistente
  - Endpoint para listar modelos disponÃ­veis do Groq
  - **MemÃ³ria global por usuÃ¡rio**: Perfil persistente que transcende sessÃµes
  - **ExtraÃ§Ã£o automÃ¡tica**: DetecÃ§Ã£o de nome, profissÃ£o e idade nas mensagens
  - **Contexto inteligente**: InformaÃ§Ãµes do usuÃ¡rio incluÃ­das automaticamente em conversas
  - **Sistema "Lembre-se disso"**: Salvamento explÃ­cito de fatos pelo usuÃ¡rio
  - **Palavras-chave inteligentes**: DetecÃ§Ã£o automÃ¡tica de comandos de salvamento
  - **ConfirmaÃ§Ã£o visual**: Feedback imediato quando informaÃ§Ãµes sÃ£o salvas
  - **GestÃ£o de fatos**: Limite automÃ¡tico e prevenÃ§Ã£o de duplicatas

### Notes
- O sistema mantÃ©m compatibilidade com a estrutura existente do projeto
- As conversas sÃ£o armazenadas de forma segura no banco SQLite local
- Cada sessÃ£o Ã© isolada, permitindo mÃºltiplas conversas simultÃ¢neas por usuÃ¡rio
- O histÃ³rico Ã© limitado Ã s Ãºltimas 20 interaÃ§Ãµes por sessÃ£o para otimizaÃ§Ã£o de performance
- **LangChain Agent**: MantÃ©m todas as funcionalidades originais (ferramentas, busca web, operaÃ§Ãµes de arquivo) com memÃ³ria persistente
- **Groq**: Oferece modelos rÃ¡pidos e eficientes, incluindo Llama 3 e Mixtral
- **MemÃ³ria Global**: Permite que o assistente "lembre" do usuÃ¡rio mesmo em diferentes sessÃµes
  - Funciona automaticamente: quando o usuÃ¡rio diz seu nome, Ã© salvo no perfil
  - Contexto Ã© incluÃ­do em todas as conversas futuras daquele `user_id`
  - InformaÃ§Ãµes persistem mesmo apÃ³s reinicializaÃ§Ã£o do servidor
- **Sistema "Lembre-se disso"**: Controle total do usuÃ¡rio sobre o que Ã© salvo
  - Palavras-chave: "lembre-se disso:", "importante:", "salvar para depois:", "nÃ£o esqueÃ§a:", "anotar:", "lembrar:"
  - Funciona em qualquer provedor (Gemini, OpenAI, Groq, LangChain)
  - Fatos sÃ£o incluÃ­dos automaticamente em futuras conversas
  - Exemplo: "lembre-se disso: eu andei de bicicleta no sÃ¡bado" â†’ salvo permanentemente
- Todos os quatro provedores (Gemini, OpenAI, Groq, LangChain) agora compartilham o mesmo sistema de memÃ³ria unificado
- Sistema escalÃ¡vel para adiÃ§Ã£o de novos provedores de IA no futuro
- **Exemplo de uso completo**: 
  - SessÃ£o 1: "Meu nome Ã© JoÃ£o" + "lembre-se disso: gosto de cafÃ©"
  - SessÃ£o 2 (semana depois): Assistente sabe

